# Для разработки
## После того, как взяли новую задачу или обновили ветку от дева
**Сборка бэкенда:** установка зависимостей, запуск миграций (при выполнении запрашивается разрешение), запуск symfony сервера
```sh
composer install --ignore-platform-reqs && php bin/console doctrine:migrations:migrate && symfony server:stop && symfony server:start --port=8080 --listen-ip=0.0.0.0
```

**Сборка фронтенда:** установка зависимостей, сборка, запуска сервера для фронта
```sh
cd frontend && npm install && npm run dev
```

Приложение будет доступно по http://localhost:5173/

Также оно будет доступно в локальной сети по `http://<your-ip>:5173/`, можно затестить в мобильной версии)

---
# Общие правила и коммуникация в команде
 - Обсуждаем задачи, возможные пути решения, построение некоторого алгоритма действий в телеграмм;
 - Работа над задачами организована с помощью `Issues`. 
   - Поэтому по мере необходимости после обсуждения создаем новую задачу, помечаем её тегами (фронт или бэк), задача также может быть и составная. Следовательно пытаемся декомпозировать и разбивать на саб-таски - более мелкие задачи;
   - Описание задачи должно полностью отражать ожидаемый результат;
   - Остальное описано в пункте по работе с гитом.
---

# Стиль написания кода

## Бэкенд
   - https://www.php-fig.org/psr/psr-12/
   - Используем `camelCase` для переменных и методов, `PascalCase` для классов;
   - Используем строгую типизацию (`declare(strict_types=1)`);
   - Используем DTO для входных/выходных данных;
   - Возвращаем JsonResponse для API;
   - Используем Enum для констант.
## Фронтенд 
   - https://vuejs.org/style-guide/
   - Используем Composition API с <script setup>;
   - Используем `camelCase` для методов и переменных, `PascalCase` для компонентов;
   - Используем `kebab-case` для Vue компонентов, `camelCase` для остальных.

Комментарии кода желательно оставлять только в необходимых местах, излишнее комментирование приводит к плохой читаемости кода.

# Для работы с гитом:

Создаем ветку от `dev`, называем так, как звучит ваша задача:

```git checkout origin/dev```

```git fetch```

```git pull```

Ну или `update` в пхп шторме

Создаем в Github issue, поменяем тегами (Backend, Frontend), там же можно сразу создать ветку **от ветки `dev`**

```git checkout -b «название» origin/dev```

коммиты тогда называем так: `<номер таски>-Название-коммита` (Осмысленные сообщения коммитов, чтобы по названию было понятно, что предполагает собой коммит)

Изменяете, пушите

## ! Пушить напрямую в мастер или дев нельзя !

После пуша в своей ветке `создаем пулл реквест` в `dev` и кидаем его другому бэку/фронту

### Смотрим код, пишем предложения и если все ок, то мержим этот пулл реквест в дев

### В ветку `master` будет сливаться стабильная версия.

---

# Настройка проекта перед разработкой
## Установить:
- `PhpStorm` (пока активировать триальный период, потом скину активатор)
- `PHP 8.2` (уже вышел 8.4 с большой обновой, но мне лень накатывать для этого проекта и менять конфигурацию в phpstorm)
- Установить `Composer`
- `Symfony  CLI`
- `NVM` (менеджер версий Node js), потом сделать nvm use <версия>. короче можно пока выбрать любую актуальную версию, потом все определимся, чтобы у всех была одинаковая.
- Установить `npm`
- Клонируем проект
- Ставим переносы строк `LF`, а не CRLF

**Сгенерировать JWT-ключи:**
```
mkdir -p config/jwt
openssl genpkey -algorithm RSA -out config/jwt/private.pem -aes256 -pass pass:<your_password>
openssl pkey -in config/jwt/private.pem -out config/jwt/public.pem -pubout -passin pass:<your_password>
```
Далее вставить код ниже в `.env` и в JWT_PASSPHRASE вставить введенный в команду пароль:
```
CORS_ALLOW_ORIGIN='^https?://(localhost|127\.0\.0\.1)(:[0-9]+)?$'

JWT_SECRET_KEY=%kernel.project_dir%/config/jwt/private.pem
JWT_PUBLIC_KEY=%kernel.project_dir%/config/jwt/public.pem
JWT_PASSPHRASE=your_password
```

**Решение проблемы долгих ответов от локального встроенного Symfony сервера:**_
Оптимизируем работу php в `php.ini` (в папке, где находится исполняемый файл `php.exe`):
- установить realpath_cache_size = 4096k
- установить realpath_cache_ttl = 7200

---

У каждого все будет локально, база у всех своя, поэтому обязательно при переходе к новой задачи запускаем команды, написанные в начале

Файл .env содержит переменные окружения, там будут указаны данные о вашей базе


# Структура проекта:
## Backend

- Весь код проекта распологается в `src`
  - Controller - контроллеры;
  - Entity - сущности БД;
  - Repository - запросы к БД;
  - DTO - классы для валидации request`ов;
  - Enum - классы, содержащие константы, используемые сущностями;
  - Helper - классы helper`ы, содержащие вспомогательные функции.

## Frontend
- Весь код проекта распологается в `frontend/src`
  - api - директория с логикой работы с `axios`, авторизацией и jwt;
  - assets - стили и логотип
  - components - компоненты
  - pages - страницы
  - router - логика работы с vue-router
  - store - vuex + localStorage
  - utils - вспомогательные функции, хелперы и тд

# Как фронтенд общается с бэкендом

## Раньше:
Пользователь переходит по URL, контроллер его обрабатывает и рендерит Twig. В нем опрокидывается файл Vue и фронт пишется в нем.
Также при необходимости с бека можно передать в twig какие-то данные, а из twig их передать на vue.
https://symfony.ru/doc/current/templates.html

В ином случае во vue файле нужно отправлять `fetch` запрос на получение данных на определенный URL, а бэк отправляет ответ.

## Сейчас мы перешли от монолитной к микросервисной архитектуре:
При авторизации бэкенд отправляет `jwt-token`, фронт запоминает его и вставляет в заголовки при дальнейших запросах на `/api`.

Без данного токена Symfony Security не отдаст запрашиваемые данные и не поймет, какой пользователь их запрашивает.
